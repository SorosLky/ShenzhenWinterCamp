###Exercise 1
def factorial(n):      #Define a function
    for i in range(n):
        if n <=1 :
            return 1
        else:
            return n * factorial(n -1)

print (factorial(6))



###Exercise 2
from random import normalvariate
import matplotlib.pyplot as plt

def white_noise(mu, sigma, ts_length=100 , initial_value = 0):  #Rewrite the function with 'While'
    epsilon_values = []   # An empty list
    while initial_value < ts_length // 2:              # First half of time series
        e = normalvariate(mu, sigma)
        epsilon_values.append(e)
        initial_value += 1 
    while initial_value >= ts_length // 2 and initial_value<= ts_length:
        e = normalvariate(mu, 10 * sigma)
        epsilon_values.append(e)           # Second half of time series
        initial_value += 1
    plt.plot(epsilon_values)
    plt.show()

white_noise(0.0 , 1.0, 10)



###Exercise 3
from random import normalvariate
import matplotlib.pyplot as plt

def generate_AR1(mu , rho , T = 200):
    epsilon_values = []   # An empty list
	
    if mu < 0 or rho < 0:
        return 'Error input'
    else:
        epsilon_values = []   # An empty list
        for i in range(0, T):
            if i < 1:
                epsilon_values.append(10)
            else:
                epsilon_values.append(mu + rho * epsilon_values[ i - 1] + normalvariate(0.0, 1.0))		
				
        plt.plot(epsilon_values)
        plt.show()
		
generate_AR1(5, 0.8, T = 200)



###Exercise 3_plus
from random import normalvariate
import matplotlib.pyplot as plt

def generate_AR1(mu , rho, T = 200):
    epsilon_values = []   # An empty list
	
    if mu < 0 or rho < 0:
        return 'Error input'
    else:
        epsilon_values = []   # An empty list
        for i in range(0, T):
            if i < 1:
                epsilon_values.append(10)
            else:
                epsilon_values.append(mu + rho * epsilon_values[ i - 1] + normalvariate(0.0, 1.0))		
				
        plt.plot(epsilon_values)
        plt.show()

for mu in range(0, 10):
    for rho in range(1, 99):
        generate_AR1(mu, rho / 100.0, T = 200)
